# Helper classes for Expressive

[![Build Status](https://secure.travis-ci.org/zendframework/zend-expressive-helpers.svg?branch=master)](https://secure.travis-ci.org/zendframework/zend-expressive-helpers)
[![Coverage Status](https://coveralls.io/repos/github/zendframework/zend-expressive-helpers/badge.svg?branch=master)](https://coveralls.io/github/zendframework/zend-expressive-helpers?branch=master)

Helper classes for [Expressive](https://github.com/zendframework/zend-expressive).

## Installation

Install this library using composer:

```bash
$ composer require zendframework/zend-expressive-helpers
```

## Helpers Provided

- [URL Helper](#urlhelper)
- [Server URL Helper](#serverurlhelper)
- [BodyParams middleware](#bodyparams-middleware)
- [Content-Length middleware](#content-length-middleware)
- [Template Variable Container](#template-variable-container)
- [Route template variable middleware](#route-template-variable-middleware)

### UrlHelper

`Zend\Expressive\Helper\UrlHelper` provides the ability to generate a URI path
based on a given route defined in the `Zend\Expressive\Router\RouterInterface`.
The provided `Zend\Expressive\Helper\UrlHelperMiddleware` can look for a
`Zend\Expressive\Router\RouteResult` request attribute, and, if present, inject
the `UrlHelper` with it; when this occurs, if the route being used to generate
a URI was also the one matched during routing, you can provide a subset of
routing parameters, and any not provided will be pulled from those matched.

To register the `UrlHelperMiddleware`:

```php
use Zend\Expressive\Helper\UrlHelperMiddleware;
use Zend\Expressive\Router\Middleware\DispatchMiddleware;
use Zend\Expressive\Router\Middleware\RouteMiddleware;

$app->pipe(RouteMiddleware::class);
$app->pipe(UrlHelperMiddleware::class);
$app->pipe(DispatchMiddleware::class);

// Or use configuration:
// [
//     'middleware_pipeline' => [
//         'routing' => [
//             'middleware' => [
//                 RouteMiddleware::class,
//                 UrlHelperMiddleware::class,
//                 DispatchMiddleware::class,
//             ],
//             'priority' => 1,
//         ],
//     ],
// ]
```

Compose the helper in your handler (or elsewhere), and then use it to
generate URI paths:

```php
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Zend\Diactoros\Response;
use Zend\Expressive\Helper\UrlHelper;

class FooHandler implements RequestHandlerInterface
{
    private $helper;

    public function __construct(UrlHelper $helper)
    {
        $this->helper = $helper;
    }

    public function handle(ServerRequestInterface $request) : ResponseInterface
    {
        $response = new Response();

        return $response->withHeader(
            'Link',
            $this->helper->generate('resource', ['id' => 'sha1'])
        );
    }
}
```

You can use the methods `generate()` and `__invoke()` interchangeably (i.e., you
can use the helper as a function if desired). The signature is:

```php
function (
    string $routeName = null,
    array $routeParams = [],
    array $queryParams = [],
    string $fragmentIdentifier = null,
    array $options = []
) : string
```

Where:

- `$routeName` is the name of a route defined in the composed router. You may
  omit this argument if you want to generate the path for the currently matched
  request.
- `$routeParams` is an array of substitutions to use for the provided route, with the
  following behavior:
  - If a `RouteResult` is composed in the helper, and the `$routeName` matches
    it, the provided `$params` will be merged with any matched parameters, with
    those provided taking precedence.
  - If a `RouteResult` is not composed, or if the composed result does not match
    the provided `$routeName`, then only the `$params` provided will be used
    for substitutions.
  - If no `$params` are provided, and the `$routeName` matches the currently
    matched route, then any matched parameters found will be used.
    parameters found will be used.
  - If no `$params` are provided, and the `$routeName` does not match the
    currently matched route, or if no route result is present, then no
    substitutions will be made.

Each method will raise an exception if:

- No `$routeName` is provided, and no `RouteResult` is composed.
- No `$routeName` is provided, a `RouteResult` is composed, but that result
  represents a matching failure.
- The given `$routeName` is not defined in the router.

#### Base Path support

If your application is running under a subdirectory, or if you are running
pipeline middleware that is intercepting on a subpath, the paths generated
by the router may not reflect the *base path*, and thus be invalid. To
accommodate this, the `UrlHelper` supports injection of the base path; when
present, it will be prepended to the path generated by the router.

As an example, perhaps you have middleware running to intercept a language
prefix in the URL; this middleware could then inject the `UrlHelper` with the
detected language, before stripping it off the request URI instance to pass on
to the router:

```php
use Locale;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Zend\Expressive\Helper\UrlHelper;

class LocaleMiddleware implements MiddlewareInterface
{
    private $helper;

    public function __construct(UrlHelper $helper)
    {
        $this->helper = $helper;
    }

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface
    {
        $uri = $request->getUri();
        $path = $uri->getPath();
        if (! preg_match('#^/(?P<lang>[a-z]{2})/#', $path, $matches)) {
            return $handler->handle($request);
        }

        $lang = $matches['lang'];
        Locale::setDefault($lang);
        $this->helper->setBasePath($lang);

        return $handler->handle(
            $request->withUri(
                $uri->withPath(substr($path, 3))
            )
        );
    }
}
```

(Note: if the base path injected is not prefixed with `/`, the helper will add
the slash.)

Paths generated by the `UriHelper` from this point forward will have the
detected language prefix.

### ServerUrlHelper

`Zend\Expressive\Helper\ServerUrlHelper` provides the ability to generate a full
URI by passing only the path to the helper; it will then use that path with the
current `Psr\Http\Message\UriInterface` instance provided to it in order to
generate a fully qualified URI.

In order to use the helper, you will need to inject it with the current
`UriInterface` from the request instance. To automate this, we provide
`Zend\Expressive\Helper\ServerUrlMiddleware`, which composes a `ServerUrl`
instance, and, when invoked, injects it with the URI instance.

As such, you will need to:

- Register the `ServerUrlHelper` as a service in your container.
- Register the `ServerUrlMiddleware` as a service in your container.
- Register the `ServerUrlMiddleware` early in your middleware pipeline.

To register the `ServerUrlMiddleware` in your middleware pipeline:

```php
use Zend\Expressive\Helper\ServerUrlMiddleware;
use Zend\Expressive\Router\Middleware\DispatchMiddleware;
use Zend\Expressive\Router\Middleware\RouteMiddleware;

// Do this early, before piping other middleware or routes:
$app->pipe(ServerUrlMiddleware::class);

/* ... */
$app->pipe(RouteMiddleware::class);
$app->pipe(DispatchMiddleware::class);

// Or use configuration:
// [
//     'middleware_pipeline' => [
//         [
//             'middleware' => ServerUrlMiddleware::class,
//             'priority' => PHP_INT_MAX,
//         ],
//     ],
// ]
```

Compose the helper in your hanlder (or elsewhere), and then use it to
generate URI paths:

```php
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Zend\Diactoros\Response;
use Zend\Expressive\Helper\ServerUrlHelper;

class FooHandler implements RequestHandlerInterface
{
    private $helper;

    public function __construct(ServerUrlHelper $helper)
    {
        $this->helper = $helper;
    }

    public function handle(ServerRequestInterface $request) : ResponseInterface
    {
        $response = new Response();

        return $response->withHeader(
            'Link',
            $this->helper->generate() . '; rel="self"'
        );
    }
}
```

You can use the methods `generate()` and `__invoke()` interchangeably (i.e., you
can use the helper as a function if desired). The signature is:

```php
function (string $path = null) : string
```

Where:

- `$path`, when provided, can be a string path to use to generate a URI.

### BodyParams middleware

One aspect of PSR-7 is that it allows you to parse the raw request body, and
then create a new instance with the results of parsing that later processes can
fetch via `getParsedBody()`. It does not provide any actual facilities for
parsing, which means you must write middleware to do so.

This package provides such facilities via `Zend\Expressive\Helper\BodyParams\BodyParamsMiddleware`.
By default, this middleware will detect the following content types:

- `application/x-www-form-urlencoded` (standard web-based forms, without file
  uploads)
- `application/json`, `application/*+json` (JSON payloads)

You can register it manually:

```php
use Zend\Expressive\Helper\BodyParams\BodyParamsMiddleware;

$app->pipe(BodyParamsMiddleware::class);
```

or, if using Expressive, as pipeline middleware:

```php
// config/autoload/middleware-pipeline.global.php
use Zend\Expressive\Helper;

return [
    'dependencies' => [
        'invokables' => [
            Helper\BodyParams\BodyParamsMiddleware::class => Helper\BodyParams\BodyParamsMiddleware::class,
            /* ... */
        ],
        'factories' => [
            /* ... */
        ],
    ],
    'middleware_pipeline' => [
        [
            'middleware' => Helper\BodyParams\BodyParamsMiddleware::class,
            'priority' => 1000,
        ],
        'routing' => [
            /* ... */
        ],
    ],
];
```

#### Strategies

If you want to intercept and parse other payload types, you can add *strategies*
to the middleware. Strategies implement `Zend\Expressive\Helper\BodyParams\StrategyInterface`:

```php
namespace Zend\Expressive\Helper\BodyParams;

use Psr\Http\Message\ServerRequestInterface;

interface StrategyInterface
{
    /**
     * Match the content type to the strategy criteria.
     *
     * @param string $contentType
     * @return bool Whether or not the strategy matches.
     */
    public function match($contentType);

    /**
     * Parse the body content and return a new response.
     *
     * @param ServerRequestInterface $request
     * @return ServerRequestInterface
     */
    public function parse(ServerRequestInterface $request);
}
```

You then register them with the middleware using the `addStrategy()` method:

```php
$bodyParams->addStrategy(new MyCustomBodyParamsStrategy());
```

To automate the registration, we recommend writing a factory for the
`BodyParamsMiddleware`, and replacing the `invokables` registration with a
registration in the `factories` section of the `middleware-pipeline.config.php`
file:

```php
use Zend\Expressive\Helper\BodyParams\BodyParamsMiddleware;

class MyCustomBodyParamsStrategyFactory
{
    public function __invoke($container)
    {
        $bodyParams = new BodyParamsMiddleware();
        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());
        return $bodyParams;
    }
}

// In config/autoload/middleware-pipeline.config.php:
use Zend\Expressive\Helper;

return [
    'dependencies' => [
        'invokables' => [
            // Remove this line:
            Helper\BodyParams\BodyParamsMiddleware::class => Helper\BodyParams\BodyParamsMiddleware::class,
            /* ... */
        ],
        'factories' => [
            // Add this line:
            Helper\BodyParams\BodyParamsMiddleware::class => MyCustomBodyParamsStrategy::class,
            /* ... */
        ],
    ],
];
```

#### Removing the default strategies

If you do not want to use the default strategies (form data and JSON), you can
clear them from the middleware using `clearStrategies()`:

```php
$bodyParamsMiddleware->clearStrategies();
```

Note: if you do this, **all** strategies will be removed! As such, we recommend
doing this only immediately before registering any custom strategies you might
be using.

### Content-Length middleware

In some cases, you may want to include an explicit `Content-Length` response
header, without having to inject it manually. To facilitate this, we provide
`Zend\Expressive\Helper\ContentLengthMiddleware`.

This middleware delegates the request, and operates on the returned response. It
will return a new response with the `Content-Length` header injected under the
following conditions:

- No `Content-Length` header is already present AND
- the body size is non-null.

To register it in your application, you will need to do two things: register the
middleware with the container, and register the middleware in either your
application pipeline, or within routed middleware.

To add it to your container, add the following configuration:

```php
// In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:

use Zend\Expressive\Helper;

return [
    'dependencies' => [
        'invokables' => [
            Helper\ContentLengthMiddleware::class => Helper\ContentLengthMiddleware::class,
        ],
    ],
];
```

To register it as pipeline middleware to execute on any request:

```php
// In `config/pipeline.php`:

use Zend\Expressive\Helper;

$app->pipe(Helper\ContentLengthMiddleware::class);
```

To register it within a routed middleware pipeline:

```php
// In `config/routes.php`:

use Zend\Expressive\Helper;

$app->get('/download/tarball', [
    Helper\ContentLengthMiddleware::class,
    Download\Tarball::class,
], 'download-tar');
```

### Template Variable Container

> - Since 5.2.0

[zend-expressive-template](https://github.com/zendframework/zend-expressive-template)
provides the method `Zend\Expressive\Template\TemplateRendererInterface::addDefaultParam()`
for providing template variables that should be available to any template.

One common use case for this is to set things such as the current user, current
section of the website, currently matched route, etc. Unfortunately, because the
method changes the internal state of the renderer, this can cause problems in an
async environment, where those changes will persist for parallel and subsequent
requests.

To provide a stateless alternative, you can create a `Zend\Expressive\Helper\Template\TemplateVariableContainer`
and persist it as a request attribute. This allows you to set template variables
that are pipeline-specific, and later extract and merge them with
handler-specific values when rendering.

To facilitate this further, we provide `Zend\Expressive\Helper\Template\TemplateVariableContainerMiddleware`,
which will populate the attribute for you if it has not yet been.

The container is **immutable**, and any changes will result in a new instance.
As such, any middleware that is providing additional values or removing values
**must** call `$request->withAttribute()` to replace the instance, per the
examples below.

As an example, consider the following pipeline:

```php
use Psr\Container\ContainerInterface;
use Zend\Expressive\Application;
use Zend\Expressive\Handler\NotFoundHandler;
use Zend\Expressive\Helper\ServerUrlMiddleware;
use Zend\Expressive\Helper\Template\TemplateVariableContainerMiddleware;
use Zend\Expressive\Helper\UrlHelperMiddleware;
use Zend\Expressive\MiddlewareFactory;
use Zend\Expressive\Router\Middleware\DispatchMiddleware;
use Zend\Expressive\Router\Middleware\ImplicitHeadMiddleware;
use Zend\Expressive\Router\Middleware\ImplicitOptionsMiddleware;
use Zend\Expressive\Router\Middleware\MethodNotAllowedMiddleware;
use Zend\Expressive\Router\Middleware\RouteMiddleware;
use Zend\Stratigility\Middleware\ErrorHandler;

use function Zend\Stratigility\path;

return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {
    $app->pipe(ErrorHandler::class);
    $app->pipe(ServerUrlMiddleware::class);

    $app->pipe(path(
        '/api/doc',
        $factory->lazy(TemplateVariableContainerMiddleware::class)
    ));

    $app->pipe(RouteMiddleware::class);

    $app->pipe(ImplicitHeadMiddleware::class);
    $app->pipe(ImplicitOptionsMiddleware::class);
    $app->pipe(MethodNotAllowedMiddleware::class);
    $app->pipe(UrlHelperMiddleware::class);

    $app->pipe(DispatchMiddleware::class);

    $app->pipe(NotFoundHandler::class);
};
```

Any middleware or handler that responds to a path beginning with `/api/doc` will
now have a `Zend\Expressive\Helper\Template\TemplateVariableContainer` attribute
that contains an instance of that class.

Within middleware that responds on that path, you can then do the following:

```php
use Zend\Expressive\Helper\Template\TemplateVariableContainer;
use Zend\Expressive\Router\RouteResult;

$container = $request->getAttribute(
    TemplateVariableContainer::class,
    new TemplateVariableContainer()
);

// Since containers are immutable, we re-populate the request:
$request = $request->withAttribute(
    TemplateVariableContainer::class,
    $container->merge([
        'user'  => $user,
        'route' => $request->getAttribute(RouteResult::class),
    ])
);
```

In a handler, you will call `mergeForTemplate()` with any local variables you
want to use, including those that might override the defaults:

```php
use Zend\Expressive\Helper\Template\TemplateVariableContainer;

$content = $this->renderer->render(
    'some::template',
    $request
        ->getAttribute(TemplateVariableContainer::class)
        ->mergeForTemplate([
            'local' => $value,
        ])
);
```

The `TemplateVariableContainer` contains the following methods:

- `count() : int`: return a count of variables in the container.
- `get(string $key) : mixed`: return the value associated with `$key`; if not
  present, a `null` is returned.
- `has(string $key) : bool`: does the container have an entry associated with
  `$key`?
- `with(string $key, mixed $value) : self`: return a new container instance
  containing the key/value pair provided.
- `without(string $key) : self`: return a new container instance that does not
  contain the given `$key`.
- `merge(array $values) : self`: return a new container that merge the `$values`
  provided with those in the original container. This is useful for setting
  many values at once.
- `mergeForTemplate(array $values) : array`: merge `$values` with any values in
  the container, and return the result. This method has no side effects, and
  should be used when preparing variables to pass to the renderer.

### Route template variable middleware

> - Since 5.2.0

`Zend\Expressive\Helper\Template\RouteTemplateVariableMiddleware` will inject
the currently matched route into the [template variable container](#template-variable-container).

This middleware relies on the `TemplateVariableContainerMiddleware` preceding
it in the middleware pipeline, or having the `TemplateVariableContainer`
request attribute present; if neither is present, it will generate a new
instance.

It then populates the container's `route` parameter using the results of
retrieving the `Zend\Expressive\Router\RouteResult` request attribute; the value
will be either an instance of that class, or `null`.

Templates rendered using the container can then access that value, and test for
routing success/failure status, pull the matched route name, route, and/or
parameters from it.

This middleware can replace the [UrlHelperMiddleware](#urlhelper) in your
pipeline.

## Documentation

See the [zend-expressive](https://github.com/zendframework/zend-expressive/blob/master/doc/book)
documentation tree, or browse online at https://docs.zendframework.com/zend-expressive/features/helpers/intro/
